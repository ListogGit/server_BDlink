Переменные 
Объявление
let - локальная
var - глобальная
Приравнивание
=
let user = "hu">, age = 12;

2.типы данных
Typeof() - для вывода типа данных перемнной

1) Number 3, 42, 1.5 
2) Tring "Привет" , "World" , "15"
3) Булевы (boolean) : true/false
4) Null (пустота);
5) Undefined (не определена);
6) Symbols (символы)
7) Objects: массивы(arrays), object, class, function


3.Взаимодействия (всплывающие окна)

1)alert(); - окно с подсказкой
2)prompt(); - поле ввода с клавиатуры
3)confirm(); - подтверждение пользователя


4. Преобразование типов данных.

В Number: Number()
В Number: parseint(); 
В string: String();
В boolean: boolean();


5. Мат. операции

+
-
*
/
** возведение в степень
%  остаток от деления

6 Операторы сравнения 
< Условие верно если первый операнд меньше второго
> Условие верно если первый операнд больше второго
<= Условие верно если первый операнд меньше или равен второму
>= Условие верно если первый операнд больше или равен второму
== Условие верно если два операнда равны
!= Условие верно если два операнда неравны 
=== Условие верно если два операнда равны но сравнение происходит без преобразования 

7 Условные операторы
if используется при выполнении кода если указанное условие в () истинное (true)
else if используется для проверки доп условий если предыдущие не были истины
else используется для выполненя клда если ни 

8 Тернарные операторы
ПОзволяют сократить написание кода. Ответ выводится по условию: TRUE | FALSE 

9 Логические операторы 
Логическое И (&&)
Логическое ИЛИ (||)
Логическое НЕ (!)
Логическое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)

10 Циклы WHILE и FOR 
1 while () {...} 
2 do {...} while ()
3 for (...) {...}
for состоит из 3 частей : 
 инициализация ; условие; выражение обновления

11 Прерывание цикла BREAK и продолжение CONTINUE
пример : программа подсчитывает сумму вводимых чисел до тех пор пока пользователь их вводит

CONTINUE пример: выводит только нечетные значения

12 switch и case
switch () {...}

13 Функции 
1 Объявление
2 Передача параметров ()
3 Тело Функции {}
4 Вызов Функции (Передача аргументов)

14 Объекты
let user = new Object(): // "Конструктор"
let user = {}; // "Литерал"

15. Массивы Методы работы с массивами
15.1 Добавление удаление в массиве
1) push(...) - добавляет элемент в конец массива
2) pop() - удаляет последний элемент массива
3) shift() - удаляет первый элемент массива
4) unshift(...) - добавляет элемент в начало массива

15.2 Поиск элементов в массиве
1) indexOf() - возвращает индекс первого элемента
2) includes() - проверяет есть ли элемент в массиве
let mixedArray = [1, "Hello", true];
mixedArray.push(5);
console.log(mixedArray);

15.3 Изменение порядка элементов
1) sort() - сортирует элементы массива
2) reverse() - изменяет порядок элементов на обратный

15.4 Применение функции к каждому элементу
1) map() - создает новый массив применяя функцию ко всем элементам
2) forEach() - выполняет функцию для всех элементов массива не возвращая новый массив
let mixedArray = [1, 2, 3];
let sad = mixedArray.map(num => num * num);
console.log(sad.join(" "));

15.5 Фильтрация массивов
1) filter() - возвращает новый массив содержащий элементы, которые соответсвуют условию
//Выводит четные числа
let mixedArray = [1, 2, 3, 4, 7 ,10];
let sad = mixedArray.filter(num => num % 2 == 0);
console.log(sad.join(" "));

15.6 Слияние массивов
1) concat() - объеденяет два или более массивов

15.7 Извлечения части массива
1) slice() - возвращает новый массива, содержащий часть оригинального

15.8 

let user = {
    name: "John",
    age: 30
};
alert(user.name);


let user = {};
user["pp"] = "a";
alert(user.pp)
delete user["pp"];
alert(user.pp)

let user = {
    name: "heu",
    age:40,
};
let key = prompt("cho hochish?");
alert(user[key])

вывод функции с объектом и свойствами

function user(name, age){
    return{
        name: name,
        age: age
    }
}
let userbase = user(prompt("ваше имя"), +prompt("ваш возвраст"));
let a = [userbase.name, userbase.age].join(' ');
alert(a)
alert("name" in userbase); //проверить существование типа

Работа в Dom

1- innerHTML -получение html содежиого

2- getElementById

3- textcontent -  получение 

4 addEventListener

document.getElementById("clickbut").addEventListener("click", addText);
function addText(){
    document.getElementById("title").textContent = "ahuet";
}
 
  5 querySelector("") - возвращает первый елемент который соответсвует указанному css селектору

  7.setAttribute - значение атрибуту
  8.removeAttribute
  9 classList.add / classList.remove 
  10 Добавление стилей 

    const ele = document.getElementById("first") ;
ele.classList.add ("text33") ;
setTimeout(() => {
    ele.classList.remove("text33");
},5000 );   

  11 create element (тег) - добавление тега 
  appendChild (") - добавление дочернего блока с конентом

  const newElement = document.createElement("h1") ;
newElement.textContent = 'Максимально не приятный человек' ;
document.getElementById("first").appendChild(newElement) ;

12removeChild();


-----------------------------------------------------------------------------------------
let a = 2;
let b = 2;
let c = "2"
let d = "2"
console.log ((a+b)*(c+d));

alert ("А">"Б");

let x= 5;
if (x>5) {
    console.log ("X больше или равно 5")
} else if  
  (  x===5)
  {
console.log("x равен 5");
  }
else {
    console.log ("Х меньше 5");
}

let x =3;
let message = (x>5) ? "х больше 5" : "x меньше 5";
console.log (message);

let year = prompt("В каком году была опубликована кнмга")
if (year == 2015) {
    alert ("Verno");
}
else
{
    alert("Ne verno");
}

let x = true;
let y = false;
console.log (x && y);
console.log(x || y);
console.log (!x);
console.log ((x && !y ) || (!x && y));

let durov = prompt ("chislo?");
let message =  (durov <= 100 && durov >= 10) ? "kaif" : "grustno";
alert(message);

let durov =  prompt("age?");
let message =  (durov >= 18 ) ? "можно" : "нельзя";
alert(message);

Напишите прогу которая запрашивает условия у пользователя логин и пароль если логин = админ а пароль пасворд выводится в алерт успешный вход в противном случае выводится сообщение о том что данные не верны



let login = prompt ("Login:");
let password = prompt ("Password:");
if ( login == "admin" && password == "password") {
    alert ("верно");
} else{
    alert("не верно");
}

let a = prompt("проверка целого числа:");
a = a%1;
if (a>0){
    alert("не целое");
}else{
    alert(" целое");
}

let i = 1;
while ( i < 3 условие) {
  то самое
    alert(i);
    i++
}
Пока условие верно , то самое будет выполняться 

let i = 1;
do { alert(i);
i++;
}
while(i<3);  

for( let i=0; i<3;i++) {
    alert (i);
}

Напишите пргу которая запрашивает у пользователя число и выводит результ умножения этотго числа на другие (1-5)

let tislo = prompt ("4islo");
for (let a = 1 ; a<6 ; a++){
    console.log(tislo ,"*" , a , "=" , tislo * a);
}

let tislo = parseInt(prompt("4islo"));
for (let a = 1 ; a<=tislo ; a++){
    console.log(tislo ,"+" , a , "=" , tislo + a);} 

let sum = 0;
while(true) {
    let value =parseInt(prompt("vvedite 4isli"));
    if (!value) break;
    sum= sum+value;
    console.log(sum);
}

let a = 4;
switch(a){
    case 3:
        alert("Malovato");
        break;
    case 5:
        alert("Mnogo");
        break;
    case 4:
    alert("Norm"); break;
    default:
        alert("Net takogo")
}

let a=6;
switch(a){
    case 4:
        alert ("Parilno");
        break;
    case 3:
    case 5:
        alert("Neprav")
        break;  
    default:
        alert("4to");  
}

const number = +prompt ("Введите число между 0 и 3");
switch(number){
    case 0:
        alert ("Parilno");
        break;
        case 1:
            alert ("Parilno");
            break;
            case 2:
                alert ("Parilno");
break;
 case 3:
     alert ("Parilno");
      break;
}


setTimeout(wakeup, 5000) ;
function wakeup () {
alert ("Прошло 5 сек");
}
let user = "tikevennyeseme4ki", age = 1 , message = "4";
console.log(user, age);

{
    var a = 30;
}
console.log (a);
let x = 1;
let y = 2;
let z = x + y;
console.log(typeof(z));


let isGreater = 4 > 1;
alert (isGreater);
let username = prompt("ахуел?")
{
    alert (" Динаху" + username);
}
let result = confirm("удалить?")
{
    alert ("ok");
}

let strNum = 123;
let num = String(strNum);
console.log(typeof(num));

let x = 10, y = 5;
let sum = x + y;
let diff = x - y;
let prod = x * y;
let quot = x / y;
let power = x ** y;
let rem = x % y;
console.log (sum,diff,prod,quot,power,rem)

function sum (a,b) {
    return a+b;
}
let result = sum (10,5)
console.log (result);

function - стандартный способ объявления функции
функционалльные выражения - функция может быть создана как выражение и присвоена переменной, такие функции не поднимаются и их можно вызывать только после объявления

let sum = function (x,y) {
    return x + y ;
};
console.log(sum(4,3));

Стрелочные функции - сокращенный способ создания функции
const sum = (a,b) => {return(a+b)};
console.log(sum(2,3));

Анонимные функции - функции у которых нет имени , чаще всего используются как аргументы для других функций

setTimeout(function(){
    console.log ("Прошло 3 сек");
}, 3000);

функции с параметром по умоланию - можете задать параметры при умолчанию если они не будут переданы при вызове функции

function user (name="Гость"){
    console.log("Привет" + name);
}

arguments - можно передать 

function all(){
    let sum=0;
    for(let i = 0; i < arguments.length; i++ ){
        sum += arguments[i];
    }
    return sum;
}
alert(all(1,2,3));

let user = {};
user["pp"] = "a";
alert(user.pp)


Модуль 3 
РАЗРАБОТКА СЕРВЕРНОЙ ЧАСТИ

3.1 РАБОТА С БАЗОЙ ДАННЫХ.
БД - набор структурированной информации для какой-либо предметой области.
Реляционные БД - данные, представленные в виде таблицы.(excel)
Основные БД выражены в популярных предложениях: postgreSQL,mySQL, MsSQL server. 
Для работы с сервером PSQL, зачастую используется отдельное клиентское приложение.
Каждое значение первой строки является атрибутом. Значения атрибутов читаются построчно.
Для того, чтого, чтобы БД корректно работала, её необходимо нормализовать.
1. н.ф. все атрибуты и их значения атомарны(неделимы).
2. н.ф. в каждой таблице есть колонка с индивидуальными индефикаторами.
3. н.ф. когда для двух таблиц создаётся смежная таблица, которая связывает первые две.
Внешний ключ - ссылка из смежной таблицы на первичный ключ таблицы, с которой она связана.
В терминологии таблицы называются сущностями.
Первая строка в каждой таблице является критериями сущности.
Первичный ключ должен обладать следующими критериями: целое цисло, не отрицательное и не ноль, автозаполнение.
SQL запросы делят на следующие типы:
1. DDL-запрос - оператор определения данных.(СREATE, DROP)
2. DML-запрос - содержит операторы манипуляции данных, которые работают с содержимым таблицы.(UPDATE, SELECT, DELETE, INSERT)
3. DCL-запрос - операторы определения доступа к данным для разных пользователей.(GRANT, DENY)
4. TCL-запрос - язык управления транзакциями, то есть сериями комманд, которые выполняются поочерёдно.
Если хотябы одна из комманд не выполнена, все последующие тоже отменяются.(BEGIN TRANSACTION, COMMIT TRANSACTION, SAVE TRANSACTION)

ТИПЫ ДАННЫХ:
1. Наиболее подходящий тип данных для первичных ключей - это (small-, big-)serial.
2. Если количество символов примерно известно заранееи оно составялет не более 255, то правильне использовать varchar. Если нужно ограничить количество символом до 11, то пишут varchar(11).
3. Когда не известно коичество сиволов, ставится динамическая величина text.
4. Если данные имеют дробную часть, то используют тип данных - numeric
5. Для целочисленных значений без автозаполнения используется тип данных - integer.
Внешний ключ так же должен описываться через Integer.
6. Для записи даты чего-либо используют timastamp.

Запрос на вывод колчиства клиентов: 
select count(*) as total_clients from clients c 
Запрос на вывод среднего значения: 
select avg(price) as avg_price from products p 
Зарос на вывод минимального или максимального значения:
select min/max(price) as min_price from products p
Зарос на вывод количества открытых и закрытых запросов:
select count(*) as orders_count from orders o 
group by status
вывод части данных через смежную таблицу:
select order_id, fio, name,status, date from orders
join clients on clients.client_id = orders.client_id
join products on products.product_id  = orders.product_id 

left join Это операция внешнего левого соединения, которая возвращает все записи из левой(превой) таблицы и только те, совпадающие из правой(второй) таблицы, которые соответсвуют условию соединения(через оператор on)
 

4 МОДУЛЬ. КЛИЕНТ СЕРВЕРНАЯ РАЗРАБОТКА МАГАЗИНА.

сервер:
бизнес логика + сервер


сервер -  физическое или виртуальное высокопроизводительное устройство, которое должно иметь доступ к интернету. Также сервер это отдельно запущенное приложение(nodeJS)
NodeJS - Это платформа для JS, построенная на движке V8, которая позволяет запускать JS код вне браузера, на сервере и на любом компьютере.
Ключевые особенности при работе с NodeJS:
1. Асинхронность и событийно-ориентированная архитектура.
1.1 неблокирующий ввод\вывод. Когда серверу нужно выполнить операцию ввода\вывода(прочитать файл с диска, сделать запрос к бд, отправить сетевой запрос) оно не ждёт её завершения. Вместо этого, оно продолжает выполнять другой код. Как только операция завершается, вызывается специальная функция обработчик callback.
1.2 Однопоточность с циклом событий(eventloop). В основе JS лежит однопоточная модель. Однако это не значит, что он может делать одну вещь за раз. Цикл событий - это механизм, который постоянно проверяет, завершились ли какие-либо асинхронные операции. Если операция завершена, он ставит её callback в очередь на выполнение.
2. NPM(node package manager) - nodeJS поставляется со своим менеджером пакетов, это большая экосистема открытых библиотек и инструментов, которые можно установить и использовать в своём проекте.
Какие этапы работ выполняются на сервере nodeJS при разработке клиент серверных приложений
1. Создание http сервера. Подключаем expressJS. Создание экземпляра приложения и определение порта, на котром сервер будет принимать входящие и исходящие подключения.
2. Подключение к базе данных. подключаем pg. Настройка подключения к СУБД с использованием соответствующего драйвера(pg или ORM/ODM системы). Создение конфигурационного файла БД(указать параметры подключения к базе данных)
3.Разработка промежуточных обработчиков(middle-wear). Разрабатываются компоненты, которые обрабатывают входящие http запросы, до того, как они достигнут маршрута
4. Определение можелей данных. Разработка модуля, который описывает структуры данных, которые будут храниться в базе данных.(таблицы, коллекции, типы данных, связи). Это делается с помощью sql-скриптов, либо через ORM/ODM модули.
5. Создание маршрутов(routes И API-endpoints). РАзработка обработчиков для различных http запросов(GET,POST,PUT, DELETE) по определённым url адресам(endpoiut-ам). Каждый маршут соответствует конкретной операции
6. Реализация контроллеров. Написание функций - обработчико, которые привязаны к маршрутам. Эти функции содержат бизнес-логику(получают данные из запроса, взаимодействуют через модели и отправляют ответ клиенту.

Хорошим тоном является разработка дополнительных модулей, отвечающих за обработку ошибок и валидации данных, настройка переменных окружения
 HTTP-методы
Эти методы определяют действия, которые клиент хочет выполнить с серусрами на сервере. Они являются основной симантикой (логикой) restfulAPI
1. метод GET. Это безопасный метод для получения данных в бд. 
get /api/clients/1 - Данный запрос возвращает данные клиента с id=1.
2. метод POST - небезопасный(меняет состояние сервера), не иденпотентный(2 одинаковых запроса создадут два ресурса). Данные запроса передаются в теле(body).
3. метод PUT - обновить/заменить. Полное обновление или замена существующего ресурса. Небезопасный иденпотентный запрос.
4. метод PATCH - частично обновить. Применяется для изменения данных у пользователя. Небезопасный иденпотентный запрос.
5. метод DELETE - удаление указанного ресурса. Небезопасный иденпотентный запрос.

Коды ответов сервера.
Это трёхзначные числа, которые лежат от 100 до 503, которые сервер отправляет на http запрос. Они сообщают клиенту результат выполнения операции и группируются по первой цифре.
1. 1хх - информационные. 100 - сервер готов принять тело запроса.
2. 2хх - сообщение об успехе - сообщение о том, что запрос успешно обработан
3. 3хх - перенапаовление - сообщают клиенту, что для выполнения запроса необходимо выполнить дополниельное действие(перейти по другому адресу)
4. 4хх - ошибки клиента. 400 - сервер не может обработать запрос, из-за некорректного синтаксиса. 429 - клиент отправил слишком много запросов за короткое время.
5. 5хх - ошибки сервера - указывает что сервер не смог выполнить запрос по своей вине. появляется из-за бага в коде.


есть два основых способа импорта и экспорта модулей
1 - ESM это более современный формат, он соответсвует последним стандартам ECMAscript
import 'dotenv/config' 
import  Express from 'express';
import { Router } from 'express';
import * as models from ./models;
export default {myClass,class1,class2};
export const muFunc = () => {};
2 - commonjs - старый
//commonjs
requare ('dotenv').config()
const express = requare('express');
const {router} = requare('express')
module.exports = myfunc;
module.exports = {class1,class2};
exports.myfunc = () => {};

index.js - основной файл для запуска сервера, в нем импортируются модули express и dotenv
db.js - файл конфигурации бд (при этом мы работаем в виртуалОкруж)
подключение к бд происходит с помощью объекта sequelize

в папке models создаем исполняемый файл models.js в которой будем описывать сущности
SERIAL(n) > INTEGER+autoInerement+primaryKey
VARCHAR(n) > DataTypes.STRING
NUMERIC(p,s) > DataTypes.DECIMAL(p,s)

после того как описали модели данных (экземпляры классов Client,Products,Orders,Order_items) мы должны экспортировать и импортировать модели в index.js,
помимо этого необходимо добавить промис в блоке try для перезаписи ( это делается с помощью функции sequelize.sync() )

const Client = sequelize.define('clients',{
    client_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    primaryKey: true,
    autoIncrement: true
    },
    name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    rating: {
        type: DataTypes.DECIMAL,
        allowNull: false,
        defaultValue: 0
    },
    age: {
        type: DataTypes.INTEGER,
        allowNull: false
    },
    role: {
        type: DataTypes.STRING,
        allowNull: false,
        defaultValue: 'user'
    }
}
)

//// связать две таблицы
A.hasOne(B)      
B.belongsTo(A)
||||
A.hasMany(B)
B.belongsMany(A)
////

Clients.hasMany(Orders)
Orders.belongsTo(Clients)

use - это метод настройки провежуточного ПО используемого маршрутами объекта сервера express
express.json - это функция разбирающая запросы в объект формата json
get - эта функция принимает в себя три аругмента, первый это http метод (get,post,put,delete,patch и тд), второй это путь на сервер, 
и третия функция выполняющаяся по выполнению маршрута
req - клиент 
res - это объект ответа 
app.use (cors())
app.use(express.json())
app.get('/', (reg,res) => {
    res.status(200).json({
        message: 'tikva work!'
    })
})

запрос работает но его необходимо оформить правильным способом: 
1- сделать метод асинхронным
2- обезопасить код
3- добавить обработку ошибок
4- сделать маршрут более корректным

пример get запроса с таблицы БД

const {Client} = models;
const getclients = await Client.findAll();
app.use (cors())
app.use(express.json())
app.get('/api/getclients', async(reg,res) => {
    try{
        res.status(200).json(getclients)
    }
    catch(error){
        res.status(500).json({message: "ошибка сервера при получении данных"})
    }
})


http методы по разным моделям данных необходимо разнести по разным модулям
создаем папку routes в которой создаем роутеры для каждой модели данных (clientRouter, ...)
добавляем router.js которая будет главным маршрутизатором, он будет вызывать нужные функции при получении запроса с браузера